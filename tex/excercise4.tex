\begin{card}
	\frametitle{Übung 4: Primitiv rekursive Funktionen}
	\url{http://people.f4.htw-berlin.de/~hebold/htw/pka/exercises/algorithmen-rekursiveFunktionen.pdf}
\end{card}

\begin{card}
  Formulieren Sie die folgenden Ausdrücke mit Hilfe von F = ${+, \cdot}$ und ${N, O, P^m_i, S^{n+1}, R}$:
	\begin{enumerate}[a)]
    \item[a)] $a \cdot b + c$
    \item[d)] $4 \cdot (3 + x)$
    \item[e)] $(a + b) \cdot (a + b)$
    \item[h)] $(a + b) \cdot (c + d)$
	\end{enumerate}
	\hr
	\begin{enumerate}[a)]
    \item[a)] $S(+, S(\cdot, P^3_1, P^3_2), P^3_3)(a, b, c)$
    \item[d)] $S(\cdot, P^3_1, S(+, P^3_2, P^3_3))(4, 3, x)$
    \item[e)] $S(\cdot, +, +)(a, b)$
    \item[h)] $S(\cdot, S(+, P^4_1, P^4_2), S(+, P^4_3, P^4_4))(a, b, c, d)$
	\end{enumerate}
\end{card}

\begin{card}
  Formulieren Sie eine primitiv rekursive Funktion, die
  \begin{enumerate}[a)]
    \item die arithmetische Differenz bestimmt.
    \item die das Vorzeichen prüft und 0 bei 0 und 1 bei Werten > 0 liefert.
    \item das Maximum von zwei Zahlen liefert.
	\end{enumerate}
	\hr
  \begin{enumerate}[a)]
    \item
      \begin{align*}
        pre &= S(R(O, P^3_2), P^1_1, O) \\
        \dotdiv &= S(R(P^1_1, pre \circ P^3_1)), P^2_2, P^2_1)(a, b)
      \end{align*}
    \item $sign = S(R(O, N \circ O \circ P^3_2), P^1_1, O)$
    \item
      \begin{align*}
        first &= S(\cdot, S(gt, P^2_1, P^2_2), P^2_1) \\
        sec &= S(\cdot, S(gt, P^2_2, P^2_1), P^2_2) \\
        eq' &= S(\cdot, S(eq, P^2_1, P^2_2), P^2_1) \\
        max &= S(add, S(add, first, sec), eq')
      \end{align*}
	\end{enumerate}
\end{card}

\begin{card}
  Formulieren Sie eine primitiv rekursive Funktion, die
  \begin{enumerate}
    \item[d)] den ganzzahligen Rest der Werte x und y bestimmt.
    \item[e)] die Teilbarkeit einer Zahl x hinsichtlich y prüft.
    \item[f)] die Operatoren $>, \geq, =$
    \item[g)] die absolute Differenz $|a - b|$
	\end{enumerate}
	\hr
  \begin{enumerate}
    \item[d)]
      \begin{align*}
        mod(a, b) &= a \dotdiv (a \text{ div } b) \cdot b \\
        div(a, b) &= \sum\limits_{i=1}^a \lrk \text{sign} \lrk \prod\limits_{j=1}^i a \dotdiv j \cdot b \rrk \rrk
      \end{align*}
    \item[e)] nsign($a$ mod $b$)
    \item[f)] $gt = sign(x \dotdiv y)$ \\
              $eq = nsign(gt(x, y) + gt(y,x))$ \\
              $ge = gt + eq$
    \item[g)] $absDiff(a,b) = diff(a, b) + diff(b, a)$ \\
	\end{enumerate}
\end{card}

\begin{card}
  0 und N sind Funktionen $\N \rightarrow \N, P, S^{n+1}$ und R dagegen
  Funktionen auf Funktionen, d.h. Operatoren. $S^{n+1}$ ist wie folgt definiert:
  \[
    (f, g_1,..., g_n) \mapsto a \in \N = S^{n+1}(f, g_1,..., g_n)
  \]

  \begin{enumerate}[a)]
    \item Wieso kann man sagen, dass $S^{n+1}$ für mehrere Operatoren steht?
    \item Wieviele verschiedene Operatoren ergeben sich aus $S^{n+1}$?
    \item Was bedeutet es für die Programmierung, dass es mehrere Operatoren $S^{n+1} $ gibt?
  \end{enumerate}
  \hr
  \begin{enumerate}[a)]
    \item Die $n$ $g$'s werden jeweils aufgerufen und bilden damit ein Funktionsschema.
    \item $n$
    \item Overloading muss möglich sein für unterschiedliche Stelligkeiten $n$
  \end{enumerate}
\end{card}

\begin{card}
  Der Ausdruck $S^{n+1}(f, g_1, \ldots, g_n)$ abstrahiert von der Anzahl $n$ möglicher Funktionen und der Stelligkeit von $f$.
  \begin{enumerate}[a)]
    \item Begründen Sie:
    \begin{enumerate}[i)]
      \item Es handelt sich also eigentlich um $n$ verschiedene Operatoren.
      \item Die Stelligkeit von $f$ ist $n$.
      \item Die Stelligkeit der Funktionen $g_1, \ldots, g_n$ ist $m$.
    \end{enumerate}
    \item Was bedeuten i) – iii) für die Implementierung (Programmierung) von $S^{n+1}$?
  \end{enumerate}
  \hr
  \begin{enumerate}[a)]
    \item Definition: $S^{n+1}(f, g_1, \ldots, g_n)(x_1, \ldots, x_m) = f(g_1(x_i, \ldots, x_m), \ldots, g_n(x_i, \ldots, x_m))$
    \begin{enumerate}[i)]
      \item Ja, da $g_i$ $n$-mal aufgerufen wird.
      \item Ja, da die Parameter $g_1, \ldots, g_n$ sind.
      \item Ja, da die Parameter von $g_i$ $x_1, \ldots, x_m$ ist.
    \end{enumerate}
    \item
    \begin{enumerate}[i)]
      \item Overloading / Variable Parameterliste muss in der Sprache vorhanden sein und benutzt werden oder $n$ unterschiedliche Funktionen müssen definiert werden.
      \item siehe i)
      \item siehe i)
    \end{enumerate}
  \end{enumerate}
\end{card}

\begin{card}
  Die Stelligkeit $m$ der Funktionen $g_1, \ldots, g_n$ spielt für den Operator $S^{n+1}(f, g_1, \ldots, g_n)$ im Rahmen des Konzepts der rekursiven Funktionen und bei den Fragestellungen der Berechenbarkeit keine Rolle.
  \begin{enumerate}[a)]
    \item Was ist mit dieser Aussage gemeint?
    \item Was bedeutet das für die Programmierung von $S^{n+1}$ ?
  \end{enumerate}
  \hr
  \begin{enumerate}[a)]
    \item $S$ ist nur für das Zusammenbauen der Funktionen $f$ mit den $g_i$'s zuständig. Daher ist $x_1, ..., x_m$
      unwesentlich.
    \item Die Funktion $S$ muss unabhängig von allen $g_i$ und $f$ funktionieren.
  \end{enumerate}
\end{card}

\begin{card}
  Die Stelligkeit $n$ der Funktion $f$ spielt für den Operator $S^{n+1}(f, g_1, \ldots, g_n)$ im Rahmen des Konzepts der rekursiven Funktionen und bei den Fragestellungen der Berechenbarkeit keine Rolle.
  \begin{enumerate}[a)]
    \item Was ist mit dieser Aussage gemeint?
    \item Was bedeutet das für die Programmierung von $S^{n+1}$ ?
  \end{enumerate}
  \hr
  \begin{enumerate}[a)]
    \item $f$ muss $n$ Funktionen akzeptieren können. $S^{n+1}$ ist das ganze egal.
    \item Die Funktion $g$ hat eine variable Parameterliste und daher muss Currying in der Sprache möglich sein.
  \end{enumerate}
\end{card}

\begin{card}
  Die Mehrstelligkeit der rekursiven Funktionen führt nicht aus der Menge der rekursiven Funktionen hinaus. Es spielt also keine Rolle, ob man $S, R$ und $\mu$ auf n-stellige oder ein-stellige Funktionen anwendet. Mit anderen Worten: Alle n-stelligen rekursiven Funktionen können durch einstellige rekursive Funktionen dargestellt werden.
  \begin{enumerate}[a)]
    \item Beschreiben Sie die Umsetzung.
  \end{enumerate}
  \hr
  \begin{enumerate}[a)]
    \item Durch das Currying wird eine mehrstellige Funktion $f(x_1, x_2)$ in mehrere einstellige Funktionen, die
      hintereinander ausgeführt werden, umgeformt: $f(x_1)(x_2)$
  \end{enumerate}
\end{card}

\begin{card}
Sie wollen eine primitiv rekursive Funktion definieren, die die Funktion
\[
f(x) =
\begin{cases}
1 & \text{wenn $x = 1$} \\
  \frac{x}{2} & \text{wenn $x$ gerade} \\
3 \cdot x + 1 &\text{wenn $x$ ungerade}
\end{cases}
\]
berechnet, d.h. die Formulierung erfolgt ausschließlich mit den Funktionen bzw. Funktionssymbolen $N, 0, P^m_i , S, R$.
  \begin{enumerate}[a)]
    \item Warum scheitern Sie?
  \end{enumerate}
  \hr
  \begin{enumerate}[a)]
    \item Da die Rekursion durch $R$ umgesetzt wird, muss $m$ gesetzt sein, sodass eine Schleife definiert wird. Bei der Ackermann-Funktion ist unklar, wie viele Durchläufe getätigt werden müssen, um das Ergebnis zu erhalten. Daher ist eine Endlos-Schleife notwendig und primitiv rekursive Funktionen können dies nicht umsetzen.
  \end{enumerate}
\end{card}

\begin{card}
  Was bedeutet die Aussage: „Alle berechenbaren Funktionen können mit Hilfe der Funktionen $0, N, P^m_i, S^{n+1}, R$ und $\mu$ formuliert werden“ für die Programmierung?
  \hr
  Die Ackermannfunktion ist umsetzbar und Endlosschleifen sind möglich. Alle berechenbare Probleme können mit primitiv rekursiven Funktionen umgesetzt werden.
\end{card}

\begin{card}
  Was unterscheidet die folgenden Aufzählfunktionen $\N^2 \rightarrow \N$ (Paare natürlicher Zahlen auf natürliche Zahlen) voneinander:
  \begin{itemize}
    \item $c(x, y) = \frac{(x + y)(x + y + 1)}{2}$
    \item $p(x, y) = 2^x \cdot 3^y$
  \end{itemize}
  \hr
  \begin{align*}
    c(0,2) &= 3 \\
    c(2,0) &= 3 \\
    \\
    p(0,2) &= 9 \\
    p(2,0) &= 4 \\
  \end{align*}

  \begin{itemize}
    \item $c$ ist surjektiv.
    \item $p$ scheint bijektiv zu sein.
  \end{itemize}
\end{card}
