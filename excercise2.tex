\begin{card}
	\frametitle{Übung 2: Konzepte Abstraktion}
	\url{http://people.f4.htw-berlin.de/~hebold/htw/pka/exercises/konzepte-Abstraktion.pdf}
\end{card}

\begin{card}
	Knappsack:\\
	Bildet von unterschiedlichen Summen eine Menge von n Summanden. (vgl. Merkle-Hellman Verfahren)\\
	Beispiel: Die Folge der Werte $( 3, 4, 5 )$ liefert die Summen $0, 3, 4, 5, 7, 8, 9, 12$.
	\hr
	Bilde Potenzmenge der Eingabe und addiere Elemente dieser einzelnen Mengen.\\
	Zum Beispiel: $2^{\{ 3, 4, 5 \}} = \{\emptyset, \{3\}, \{4\}, \{5\}, \{3,4\}, \{4,5\}, \{3,5\}, \{3,4,5\} \}$
\end{card}

\begin{card}
	Nennen Sie mindestens 3 Gründe für Abstraktion.
	\hr
	\begin{enumerate}[a)]
	\item \textbf{Wiederverwendbarkeit} von allgemeinen Problemlösungen
	\item \textbf{Klassifizieren} von Problemen, erkennen der Struktur
	\item Allgemeine Lösung zu detaillierten Problemen ($\approx$ \textbf{Kompression})
	\item \textbf{Ver\uline{ein}fachung}, reduzieren auf gemeinsame Eigenschaft
	\end{enumerate}
\end{card}

\begin{card}
	Inwiefern wird beim Programmieren ganz generell abstrahiert?
	\hr
	\begin{itemize}
	\item OOP (A) $\Leftrightarrow$ reale Welt (K)
	\item Programmcode (A) $\Leftrightarrow$ Problembeispiele (K)
	\item Programme (A)$\Leftrightarrow$ Prozesse / Programmlauf (K)\\(vgl. Debuggen - ständiger Kontextwechsel)
	\end{itemize}
	Legende: Konkretisierung (K), Abstraktion (A)
\end{card}

\begin{card}
	Inwiefern wird bei der \textbf{strukturierten} Programmierung abstrahiert?
	\hr
	if, for, while-Konstrukte ersetzen Sprungbefehle\\
	Beispiel: 
	\begin{lstlisting}[language=C]
	while(c>0) {
	  c--;
	}
	\end{lstlisting}
	wird zu 
	\begin{lstlisting}[language=C]
	start:
	if(c <= 0) goto end;
	  c--;
	  goto start;
	
	end: ...
	\end{lstlisting}
\end{card}

\begin{card}
	Inwiefern wird bei der \textbf{prozeduralen} Programmierung abstrahiert?
	\hr
	\begin{itemize}
	\item parametrisierte Prozeduren ersetzen alle Werte-Kombinationen beim Aufruf\\
		Beispiel: f(x) $\ent$ f(1), f(2), ... f(n)
	\item Prozeduren ersetzen konkrete Implementierungen ($\approx$ \textbf{Blackbox})\\
		Beispiel: sort(array[] field) sortiert ohne, dass bekannt ist wie.
	\end{itemize}
\end{card}

\begin{card}
	Inwiefern wird bei der \textbf{modularen} Programmierung abstrahiert?
	\hr
	\begin{itemize}
	\item Kein konkreten Zustände, d.h. nur statische (vgl. \texttt{static}) Werte ($\approx$ \textbf{Zustandslos})
	\item Implementierung unbekannt, Referenzierung über Name ($\approx$ \textbf{Blackbox})\\
		Beispiel: \texttt{import java.io} $\rightarrow$ \texttt{import java.nio} bei gleicher API
	\end{itemize}
\end{card}

\begin{card}
	Inwiefern wird bei der \textbf{objekt-orientierten} Programmierung abstrahiert?
	\hr
	\begin{itemize}
	\item Vererbung, generischen Datentypen\\
			Beispiel: A extends B\\
			(A Konkretisierung  von B $\leftrightarrow$ B Generalisierung/Abstraktion von A)
	\item Polymorphismus, dynamisches Binden\\
		Beispiel:
		\begin{lstlisting}[language=Java]
		class B {
		  void f() { out.println("B"); }
		}
		
		class A extends B {
		  void f() { out.println("A"); }
		}
		
		B testA = new A();
		testA.f(); // "A"
		B testB = new B();
		testB.f(); // "B"
		\end{lstlisting}
	\end{itemize}
\end{card}

\begin{card}
	Inwiefern wird bei der \textbf{funktionalen} Programmierung abstrahiert?
	\hr
	\begin{itemize}
	\item Nur Funktionen und Rückgabewerte, keine Unterscheidung zwischen Daten(typen) und  Objekten\\
		Beispiel:
		%eigentlich JavaScript
		\begin{lstlisting}[language=Java] 
		function addiere(x,y) {
		  if (typeof y === "undefined" ) {
		    return function (y) { return x + y; }
		  }
		  return x + y;
		}
		addiere(2,4); // 6 
		var addiere_zu_drei = addiere(3)
		addiere_zu_drei(5) // 8
		\end{lstlisting}
		%Quelle: https://de.wikipedia.org/wiki/Currying#JavaScript
	\item Überladen von Funktionen\\
		Beispiel: \texttt{summe(a,b,c)} (A) und \texttt{summe(a,summe(b,c))} (K)
	\end{itemize}
\end{card}

\begin{card}
	Inwiefern wird bei der Programmierung abstrakter Datentypen abstrahiert?
	\hr
	\begin{itemize}
	\item Lists, Arrays als Abstraktion\\
		vgl. Gruppe (Math.), generische Datentypen\\
		Beispiele: 
		\begin{lstlisting}[language=Java] 
		static Object getFirst(ArrayList b) {
		   return ...
		}
		
		ArrayList a = new ArrayList<Integer>();
		...
		<?> c = getFirst(a);
		\end{lstlisting}
	\end{itemize}
\end{card}

\begin{card}
	Beim Abstraktionskonzept wird auf verschiedenen konkreten Objekten mit einem Namen referiert, wobei die Besonderheiten unberücksichtigt bleiben - von diesen wird abstrahiert.\\
	Bei der Konkretisierung wird umgekehrt einem Namen ein bestimmtes konkretes Objekt zugeordnet - der Name wird gebunden.\\
	Wann erfolgt im Rahmen der Programmierung die Konkretisierung, d.h. die Bindung	eines Namens?
	\hr
	Die Konkretisierung erfolgt zur \textbf{Laufzeit}, d.h. bei der Zuweisung wird der Typ und Name konkret festgelegt.\\
	Beispiel:
	\begin{lstlisting}[language=Java]
	// Abstraktion: Instanziierung
	List x = new ArrayList();
	// Konkretisierung: Zuweisung, Casting
	void doSth(List x) {ArrayList y=(ArrayList)x;}
	\end{lstlisting}
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird durch einen Variablennamen abstrahiert?
	\hr
	Vom konkreten Wert hinter dem Variablennamen, da nur die Referenz auf den Wert benutzt wird.\\
		Beispiel: \texttt{int x = 3; x = 7;}
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird durch Pointer abstrahiert?
	\hr
	Von der Speicheradresse\\
	Beispiel:
	\begin{lstlisting}[language=C]
	int *myPointer = 3 //Wert;
	myPointer = 1234 // Speicheradresse
	\end{lstlisting}
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird durch eine Initialisierung \texttt{int i=42} abstrahiert?
	\hr
	\begin{itemize}
	\item Speicherreservierung + Zuweisung und Belegung
	\item Darstellung
	\end{itemize}
	Beispiel: Big Endian / Little Endian (dt.: Byte-Reihenfolge)
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird durch eine Zuweisung abstrahiert?
	\hr
	TODO: hier geht es weiter...
	Von allen verschiedenen Zuweisungsoperatoren\\
	Beispiel
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird durch 
	\begin{enumerate}[a)]
	\item if-Abfrage
	\item for-Schleife \texttt{for(int i=0;i<a;i++) block} 
	\item while-Schleife
	\end{enumerate}
	abstrahiert?
	\hr
	goto + label\\
	Beispiel
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird durch eine Prozedur (void) abstrahiert?
	\hr
	Von der Implementierung\\
	Beispiel
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird durch eine Funktion (non-void) abstrahiert?
	\hr
	Von der Implementierung\\
	der Rückgabewert abstrahiert von der Funktion\\
	Beispiel
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird in C und C++ und Java durch den abstrakten Datentyp Array abstrahiert?
	\hr
	C und C++: Von Pointern, Beispiel: 
	\begin{lstlisting}
	
	\end{lstlisting}
	
	Java: Von Referenzen, Beispiel: \begin{lstlisting}
	new String[]{"a", "b", "c"}.get(0)
	\end{lstlisting}
	
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Funktionen werden in C, C++ und Java durch Aufrufe zur Laufzeit konkretisiert. Signatur und Methode sind die Abstraktionen. Zusätzlich bietet C++ Funktionen mit default Parametern. Was bedeuten diese für Abstraktion und Konkretisierung?
	\hr
	???
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird in C++ durch eine inline-Funktion abstrahiert?
	\hr
	Wie Makros als Textersetzung ohne Stack, jedoch wie Funktion mit Auswertung
\end{card}

\begin{card}
	Objektorientierte Programmierung:\\
	Von was wird in Java durch eine Referenz \texttt{Type ref} abstrahiert?
	\hr
	\texttt{Type}: Für alle Objekt-Typen und deren Ableitung von Type\\
	\texttt{ref}: Abstraktion der Objekte, aber nicht vom Objekt selbst
\end{card}

\begin{card}
	Objektorientierte Programmierung:\\
	Die meisten objektorientierter Sprachen verfügen über primitive Datentypen wie z.B. \texttt{int}. Warum haben diese primitiven Datentypen aus der Warte des Abstraktionskonzepts einen Sonderstatus?
	\hr
	\begin{itemize}
	\item Call-by-Value: Passen direkt in Referenzspeicherbereich
	\item keine Kapselung notwendig/möglich
	\item Vererbung nicht möglich bei \texttt{int}.
	\end{itemize}
\end{card}

\begin{card}
	Objektorientierte Programmierung:\\
	Was wird durch die ausschließliche Verwendung von Klassen, Objekten und Referenzen, d.h. durch die Streichung der primitiven Datentypen, im Sinne des Abstraktionskonzepts erreicht?
	\hr
	\begin{itemize}
	\item Kontinuität
	\item Gemeinsamer Oberdatentyp
	\end{itemize}
\end{card}

\begin{card}
	Objektorientierte Programmierung:\\
	C++ und Java kennen die Möglichkeit des \textbf{overriding}. Inwiefern handelt es sich um eine Abstraktion? D.h. von welchen konkrete Elementen wird abstrahiert? 
	\hr
	Funktionsname wird von der Implementierung der Objekt-Methode abstrahiert.
\end{card}

\begin{card}
	Objektorientierte Programmierung:\\
	Mehrfachvererbung ist in Java bei Klassen nicht zugelassen. 
	\begin{enumerate}[a)]
	\item Nennen Sie eine Begründung im Rahmen des Abstraktionsprinzips.
	\item Wieso ist Mehrfachvererbung bei Interfaces zugelassen?
	\item Wie löst C++ die genannten Probleme?
	\end{enumerate}
	\hr
	\begin{enumerate}[a)]
	\item Overriding von Methoden ist somit eindeutig
	\item Es steckt keine konkrete Implementierung dahinter
	\item Durch die Reihenfolge der Vererbung
	\end{enumerate}
\end{card}

\begin{card}
	Objektorientierte Programmierung:\\
	Inwiefern handelt es sich bei der Definition von superclasses um eine Abstraktion?
	\hr
	\begin{itemize}
	\item Verallgemeinerungder konkreten Klasse, mit weniger Eigenschaften
	\item Allgemeingültige Klasse für alle Unterklassen
	\item Generalisierung Richtung Oberklasse
	\end{itemize}
\end{card}

\begin{card}
	Funktionale Programmierung:\\
	Inline-Funktionen sind Teil der meisten funktionalen Sprachen. Beschreiben Sie im Rahmen des Abstraktionskonzepts das Problem mit rekursiv definierten (inline-) Funktionen.
	\hr
	Nur 1 Rückgabewert\\
	Beispiel:\\
	\vfill
	Abgrenzung: Makro $\Leftrightarrow$ Inline-Funktion\\
	Haben beide keine Stack und Heap, d.h. Textersetzung. Inline-Funktionen sehen aber aus wie Funktionen. 
	Problem bei Texterzersetzung mit Mehrfachaufruf, Beispiel: 
	\begin{lstlisting}
	Max(x,y) = {x > y ? x : y}
	Max(x++, y++)
	\end{lstlisting}
\end{card}

\begin{card}
	Funktionale Programmierung:\\
	Inwiefern kann man sagen, dass in rein funktionalen Sprachen auf einer höheren Stufe der Abstraktion programmiert wird?
	\hr
	Funktionen wie Werte veränderbar, daher nur Werte zu verarbeiten und keine Prozeduraufrufe vorhanden.\\
	Beispiel: 
\end{card}

\begin{card}
	Funktionale Programmierung:\\
	In rein funktionalen Sprachen sind Funktionen als Parameter und Rückgabewerte von Funktionen zugelassen. 
	\begin{enumerate}[a)]
	\item  Inwiefern wird dadurch eine höhere Stufe der Abstraktion erreicht, als Paradigmen bei Sprachen, die dieses Feature nicht haben?
	\item Ist es möglich, durch diese Erweiterung Probleme zu lösen, die in imperativen Sprachen nicht gelöst werden können?
	\end{enumerate}
	\hr
	\begin{enumerate}[a)]
	\item \begin{itemize}
		\item Asynchroner Ablauf, Event-basiert / Ereignis-gesteuert
		\item Dynamischer Kontrollfluss (Bsp: Callbacks), Funktionen können zur Laufzeit konstruiert/modifiziert werden.
		\item Bessere Skalierbarkeit, da bekannter Gültigkeitsbereich
		\end{itemize}
	\item  Nein. Ackermann ist iterativ nicht lösbar, sondern nur rekursiv?
	\end{enumerate}
\end{card}