\begin{card}
	\frametitle{Übung 2: Konzepte Abstraktion}
	\url{http://people.f4.htw-berlin.de/~hebold/htw/pka/exercises/konzepte-Abstraktion.pdf}
\end{card}

\begin{card}
	Nennen Sie mindestens 3 Gründe für Abstraktion.
	\hr
	\begin{enumerate}[a)]
	\item Wiederverwendbarkeit von allgemeinen Problemlösungen
	\item Klassifizieren von Problemen, erkennen der Struktur
	\item Allgemeine Lösung zu detaillierten Problemen ($\approx$ Kompression)
	\item Vereinfachung, reduzieren auf gemeinsame Eigenschaft
	\end{enumerate}
\end{card}

\begin{card}
	Inwiefern wird beim Programmieren ganz generell abstrahiert?
	\hr
	\begin{enumerate}[a)]
	\item OOP $\Leftrightarrow$ reelle Welt, internes Modell als Abstraktion
	\item Abstraktion von Problembeispielen auf Programmcode
	\item Programme $\Leftrightarrow$ Prozessen (vgl. Debuggen - ständiger Kontextwechsel)
	\end{enumerate}
\end{card}

\begin{card}
	Inwiefern wird bei der \textbf{strukturierten} Programmierung abstrahiert?
	\hr
	\begin{enumerate}[a)]
	\item if, for, while-Konstrukte ersetzen Sprungbefehle\\
		Beispiel: labels mit goto (?)
	\end{enumerate}
\end{card}

\begin{card}
	Inwiefern wird bei der \textbf{prozeduralen} Programmierung abstrahiert?
	\hr
	\begin{enumerate}[a)]
	\item parametrisierte Prozeduren ersetzen alle Werte-Kombinationen beim Aufruf\\
		Beispiel: f(x) $\ent$ f(1), f(2), ... f(n)
	\end{enumerate}
\end{card}

\begin{card}
	Inwiefern wird bei der \textbf{modularen} Programmierung abstrahiert?
	\hr
	\begin{enumerate}[a)]
	\item statische Werte, d.h. kein Zustand
	\item Blackbox, Implementierung unbekannt\\
		Beispiel: sort(array[] field) sortiert ohne, dass wir wissen wie.
	\end{enumerate}

\end{card}

\begin{card}
	Inwiefern wird bei der \textbf{objekt-orientierten} Programmierung abstrahiert?
	\hr
	\begin{enumerate}[a)]
	\item Vererbung, generischen Datentypen\\
			Beispiel: A extends B\\
			(A Konkretisierung  von B $\leftrightarrow$ B Generalisierung/Abstraktion von A)
	\item Polymorphismus, dynamisches Binden\\
			Beispiel:
	\end{enumerate}
\end{card}

\begin{card}
	Inwiefern wird bei der \textbf{funktionalen} Programmierung abstrahiert?
	\hr
	\begin{enumerate}[a)]
	\item Nur Funktionen und Rückgabewerte, keine Datentypen, bzw. Objekte\\
		Beispiel:
	\item Überladen von Funktionen\\
		Beispiel:
	\end{enumerate}
\end{card}

\begin{card}
	Inwiefern wird bei der Programmierung abstrakter Datentypen abstrahiert?
	\hr
	\begin{enumerate}[a)]
	\item Lists, Arrays als Abstraktion, vgl. Gruppe (Math.)\\
		Beispiel: new ArrayList<Integer>().get(0)
	\end{enumerate}
\end{card}

\begin{card}
	Beim Abstraktionskonzept wird auf verschiedenen konkreten Objekten mit einem Namen referiert, wobei die Besonderheiten unberücksichtigt bleiben - von diesen wird abstrahiert.\\
	Bei der Konkretisierung wird umgekehrt einem Namen ein bestimmtes konkretes Objekt zugeordnet - der Name wird gebunden.\\
	Wann erfolgt im Rahmen der Programmierung die Konkretisierung, d.h. die Bindung	eines Namens?
	\hr
	Bei der Zuweisung wird der Typ und Name konkret festgelegt: Zur Laufzeit\\
	Beispiel:
	\begin{lstlisting}[language=Java]
	// Abstraktion:
	List x = new ArrayList();
	// Konkretisierung:
	void doSth(List x) {ArrayList y=(ArrayList)x;}
	\end{lstlisting}
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird durch einen Variablennamen abstrahiert?
	\hr
	Vom Wert, da nur die Referenz auf den Wert benutzt wird\\
		Beispiel: int x = 3; x=x+4;
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird durch Pointer abstrahiert?
	\hr
	Von der Speicheradresse\\
		Beispiel
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird durch eine Initialisierung \texttt{int i=42} abstrahiert?
	\hr
	Von der Speicherdarstellung	\\
	Beispiel: Big Indian/ Little Endian(?)
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird durch eine Zuweisung abstrahiert?
	\hr
	Von allen verschiedenen Zuweisungsoperatoren\\
		Beispiel
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird durch 
	\begin{enumerate}[a)]
	\item if-Abfrage
	\item for-Schleife \texttt{for(int i=0;i<a;i++) block} 
	\item while-Schleife
	\end{enumerate}
	abstrahiert?
	\hr
	goto + label\\
	Beispiel
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird durch eine Prozedur (void) abstrahiert?
	\hr
	Von der Implementierung\\
	Beispiel
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird durch eine Funktion (non-void) abstrahiert?
	\hr
	Von der Implementierung\\
	der Rückgabewert abstrahiert von der Funktion\\
	Beispiel
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird in C und C++ und Java durch den abstrakten Datentyp Array abstrahiert?
	\hr
	C und C++: Von Pointern, Beispiel: \begin{lstlisting}
		
		\end{lstlisting}
	
	Java: Von Referenzen, Beispiel: \begin{lstlisting}
	{"a", "b", "c"}.get(0)
	\end{lstlisting}
	
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Funktionen werden in C, C++ und Java durch Aufrufe zur Laufzeit konkretisiert. Signatur und Methode sind die Abstraktionen. Zusätzlich bietet C++ Funktionen mit default Parametern. Was bedeuten diese für Abstraktion und Konkretisierung?
	\hr
	???
\end{card}

\begin{card}
	Imperative Programmierung:\\
	Von was wird in C++ durch eine inline-Funktion abstrahiert?
	\hr
	Wie Makros als Textersetzung ohne Stack, jedoch wie Funktion mit Auswertung
\end{card}

\begin{card}
	Objektorientierte Programmierung:\\
	Von was wird in Java durch eine Referenz \texttt{Type ref} abstrahiert?
	\hr
	\texttt{Type}: Für alle Objekt-Typen und deren Ableitung von Type\\
	\texttt{ref}: Abstraktion der Objekte, aber nicht vom Objekt selbst
\end{card}

\begin{card}
	Objektorientierte Programmierung:\\
	Die meisten objektorientierter Sprachen verfügen über primitive Datentypen wie z.B. \texttt{int}. Warum haben diese primitiven Datentypen aus der Warte des Abstraktionskonzepts einen Sonderstatus?
	\hr
	\begin{itemize}
	\item Call-by-Value: Passen direkt in Referenzspeicherbereich
	\item keine Kapselung notwendig/möglich
	\item Vererbung nicht möglich bei texttt{int}.
	\end{itemize}
\end{card}

\begin{card}
	Objektorientierte Programmierung:\\
	Was wird durch die ausschließliche Verwendung von Klassen, Objekten und Referenzen, d.h. durch die Streichung der primitiven Datentypen, im Sinne des Abstraktionskonzepts erreicht?
	\hr
	\begin{itemize}
	\item Kontinuität
	\item Gemeinsamer Oberdatentyp
	\end{itemize}
\end{card}

\begin{card}
	Objektorientierte Programmierung:\\
	C++ und Java kennen die Möglichkeit des \textbf{overriding}. Inwiefern handelt es sich um eine Abstraktion? D.h. von welchen konkrete Elementen wird abstrahiert? 
	\hr
	Funktionsname wird von der Implementierung der Objekt-Methode abstrahiert.
\end{card}

\begin{card}
	Objektorientierte Programmierung:\\
	Mehrfachvererbung ist in Java bei Klassen nicht zugelassen. 
	\begin{enumerate}[a)]
	\item Nennen Sie eine Begründung im Rahmen des Abstraktionsprinzips.
	\item Wieso ist Mehrfachvererbung bei Interfaces zugelassen?
	\item Wie löst C++ die genannten Probleme?
	\end{enumerate}
	\hr
	\begin{enumerate}[a)]
	\item Overriding von Methoden ist somit eindeutig
	\item Es steckt keine konkrete Implementierung dahinter
	\item Durch die Reihenfolge der Vererbung
	\end{enumerate}
\end{card}

\begin{card}
	Objektorientierte Programmierung:\\
	Inwiefern handelt es sich bei der Definition von superclasses um eine Abstraktion?
	\hr
	\begin{itemize}
	\item Verallgemeinerungder konkreten Klasse, mit weniger Eigenschaften
	\item Allgemeingültige Klasse für alle Unterklassen
	\item Generalisierung Richtung Oberklasse
	\end{itemize}
\end{card}

\begin{card}
	Funktionale Programmierung:\\
	Inline-Funktionen sind Teil der meisten funktionalen Sprachen. Beschreiben Sie im Rahmen des Abstraktionskonzepts das Problem mit rekursiv definierten (inline-) Funktionen.
	\hr
	Nur 1 Rückgabewert\\
	Beispiel:\\
	\vfill
	Abgrenzung: Makro $\Leftrightarrow$ Inline-Funktion\\
	Haben beide keine Stack und Heap, d.h. Textersetzung. Inline-Funktionen sehen aber aus wie Funktionen. 
	Problem bei Texterzersetzung mit Mehrfachaufruf, Beispiel: 
	\begin{lstlisting}
	Max(x,y) = {x > y ? x : y}
	Max(x++, y++)
	\end{lstlisting}
\end{card}

\begin{card}
	Funktionale Programmierung:\\
	Inwiefern kann man sagen, dass in rein funktionalen Sprachen auf einer höheren Stufe der Abstraktion programmiert wird?
	\hr
	Funktionen wie Werte veränderbar, daher nur Werte zu verarbeiten und keine Prozeduraufrufe vorhanden.\\
	Beispiel: 
\end{card}

\begin{card}
	Funktionale Programmierung:\\
	In rein funktionalen Sprachen sind Funktionen als Parameter und Rückgabewerte von Funktionen zugelassen. 
	\begin{enumerate}[a)]
	\item  Inwiefern wird dadurch eine höhere Stufe der Abstraktion erreicht, als Paradigmen bei Sprachen, die dieses Feature nicht haben?
	\item Ist es möglich, durch diese Erweiterung Probleme zu lösen, die in imperativen Sprachen nicht gelöst werden können?
	\end{enumerate}
	\hr
	\begin{enumerate}[a)]
	\item \begin{itemize}
		\item Asynchroner Ablauf, Event-basiert / Ereignis-gesteuert
		\item Dynamischer Kontrollfluss (Bsp: Callbacks), Funktionen können zur Laufzeit konstruiert/modifiziert werden.
		\item Bessere Skalierbarkeit, da bekannter Gültigkeitsbereich
		\end{itemize}
	\item  Nein. Ackermann ist iterativ nicht lösbar, sondern nur rekursiv?
	\end{enumerate}
\end{card}